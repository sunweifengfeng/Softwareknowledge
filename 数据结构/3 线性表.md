# 线性表

## 一. 基础
### 1. 线性表定义
零个或多个类型相同的数据元素的有限序列，每个元素都前后连接，有自己固定的位置。 就是List

### 2. 线性表的顺序存储结构
**1. 顺序存储结构代码**
```C++
#define MAXSIZE 20 // 存储空间初始分配量
typedef int ElemType; // 定义了一个和数据类型相同的类型
typedef struct
{
    ElemType data[MAXSIZE]; // 建立存储元素的数组
    int length;    // 线性表长度
}SqList;

```
顺序存储结构的三个属性：

* 存储空间的起始位置，由data决定
* 线性表最大容量
* 线性表当前长度

**数据长度和线性表长度的区别：** 线性表长度是元素个数，而数据长度跟数据类型有关，类型所占字节*元素个数。

顺序存储优点：查找方便、插入和删除较耗费资源

### 3. 线性表的链式存储结构
**1. 概念：** 链表存储两个信息，存储数据元素信息的域被称为数据域，存储直接后继位置的域被称为指针域，把两部分组合起来，叫做结点(Node)。

**2. 单链表：** 链表中每个结点只包含一个指针域的情况。
![单链表](./img/单链表.png)

**3. 头指针：** 链表中第一个结点的存储位置叫做头指针，规定线性链表的最后一个结点指针为空，即Null。
![头指针](./img/头指针.png)

**4. 头结点：** 单链表的第一个结点前的节点，称为头结点，头结点的数据域可以不存储任何信息，也可以存储长度等附加信息，头结点的指针域存储指向第一个结点的指针。
![头结点](./img/头结点.png)

带有头结点的单链表：
![头结点单链表](./img/单链表头结点.png)

#### 3.1 单链表
**1.单链表的定义、插入、查询、删除**
1.1 单链表插入原理：
在第i位置插入(插入的结点位置变为i)的算法思路：

用类似上面查找的方法，将指针移动到指向第i 个结点
让插入元素的后继指针 = 第i 个结点的后继指针
让第i个结点的后继指针 = 插入元素的地址

**2.java实现单链表**
```java
public class Node {
    //创建链表元素
    public Object data;
    public Node next;   // Node的引用

    //两个构造方法
    public Node(Object e) {
        this.data = e;
        this.next = null;
    }

    public Node() {
        this.data = null;
        this.next = null;
    }

    //删除结点
    public void del(){
        this.data = null;
        this.next = null;
    }
}

class LinkList{
    private Node head;
    private int size;

    public LinkList() {
        head = new Node();
    }

    // 创建空链表，就是头结点的下一个节点是尾结点
    public void createList(){
        head.next = null;
        size = 0;
    }

    //创建长度为n的链表 尾插法
    //1.创建头结点和尾结点，头结点的next指向null
    //2.新插入的节点node的next指向null
    //3.头结点的next指向新插入的节点node
    //4.保存新插入结点的位置（在开始就建立一个临时节点）
    public void createList(int n){
        head.next = null;
        Node old = new Node();
        for (int i = 0; i < n; i++) {
            //每一次新创建的节点 node
            Node node = new Node();
            node.next = null;
            if (i==0) {
                head.next = node;
                head.next.data=i;
            }
            else {
                old.next = node;
                old.next.data=i;
            }
            old = node;
            size = size + 1;
        }
    }

    // 链表插入元素 默认插入到最后
    //1.将当前节点转为第一个结点而不是头结点
    //2.一直next size-1次，到达尾结点之前的节点处 
    //3.让其next指向新增加的节点
    //4.新增加的节点的下一个节点指向null
    public void add(Object e){
        Node node = new Node(e);
        Node old = head.next;   // 获取第一个结点
        for (int i = 0; i < size-1; i++) {
            old = old.next; // 第一次循环之后就是第二个结点了
        }
        // 循环之后old为最后一个结点
        old.next = node;
        node.next = null;
        size = size + 1;
    }
    // 重载一下，在指定位置的后面插入元素
    //1.将当前节点遍历到被插入元素的位置
    //2.保存当前节点的next的位置
    //3.将当前节点的next指向新增加的node
    //4.将新增加的node的next指向第2步保存的位置
    public void add(Object e, int idx){
        if (idx<1 || idx>size)
            throw new IndexOutOfBoundsException("输入的索引不对");
        Node node = new Node(e);
        Node old = head;
        for (int i = 0; i < idx; i++) {
            old = old.next;
        }
        Node later = old.next; // 被插入的后面的结点
        old.next = node;
        node.next = later;
        size = size + 1;
    }

    //删除指定位置的节点
    //1.将当前指针指向被删除之前的位置node
    //2.保存要删除的节点node.next
    //3.将node.next指向node.next.next
    //4.释放删除位置的地址空间
    public void remove(int idx){
        if (idx < 1 || idx > size)
            throw new IndexOutOfBoundsException("输入的索引不对");
        Node node = head;
        for (int i = 0; i < idx-1; i++) {
            node = node.next;
        }
        Node beDel = node.next;
        node.next = node.next.next;
        beDel.del();   // 应该算是一种释放吧
        size = size - 1;
    }

    public void showAll(){
        Node node = head.next;
        for (int i = 0; i < size; i++) {
            System.out.println(node.data);
            node = node.next;
        }
    }

    // 整表删除，应该是不能直接释放LinkList对象的，这样只能释放head
    // 不知道对不对
    public void DelALL(){
        Node node = head;
        for (int i = 0; i < size; i++) {
            Node bedel = node.next;
            node.del();
            node = bedel;
        }
        size = 0;
    }

}
```

结论:

如果频繁查找，很少插入删除的化，适合用顺序存储结构
如果元素变化很大或者根本不知道多大时，最好用单链表结构

## 4 静态链表
